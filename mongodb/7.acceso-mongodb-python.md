# Acceso a MongoDB desde Python

Para conectarnos a MongoDB desde Python empregaremos a librar√≠a oficial **pymongo**, que proporciona unha API completa para realizar conexi√≥ns, inserir documentos, consultar colecci√≥ns, realizar actualizaci√≥ns, agregaci√≥ns e traballar con √≠ndices.

---

## 1. A librar√≠a **pymongo**
Para conectarmnos a **MongoDB** dende *python* imos empregar o m√≥dulo `pymongo`. Se non o temos instalado podemos facelo mediante o seguinte comando:


```python
!pip install pymongo
```

PyMongo √© a librar√≠a oficial de Python para conectarse a MongoDB. A s√∫a estrutura bas√©ase en tres obxectos principais:

1. **MongoClient** ‚Üí Conexi√≥n ao servidor/cluster
2. **Database** ‚Üí Representa unha base de datos
3. **Collection** ‚Üí Representa unha colecci√≥n dentro dunha BD

### 1.1 MongoClient
Representa a conexi√≥n co servidor ou cl√∫ster MongoDB.

**M√©todos destacados**:
- `list_database_names()` ‚Üí devolve a lista de bases de datos dispo√±ibles.
- `get_database(nome)` ou `cliente[nome]` ‚Üí obt√©n unha base de datos.
- `close()` ‚Üí pecha a conexi√≥n.

### 1.2. Database
Obxecto que representa unha base de datos concreta.

**M√©todos destacados**:
- `list_collection_names()` ‚Üí lista todas as colecci√≥ns.
- `get_collection(nome)` ou `bd[nome]` ‚Üí obt√©n unha colecci√≥n.
- `create_collection(nome)` ‚Üí crea unha colecci√≥n.
- `drop_collection(nome)` ‚Üí elimina unha colecci√≥n.

### 1.3. Collection
Obxecto que representa unha colecci√≥n.

**M√©todos destacados**: 
- Crear
    - `insert_one(documento)`
    - `insert_many([docs])`

- Ler
    - `find(filtro, proxecci√≥n)` ‚Üí devolve un cursor (iterable)
    - `find_one(filtro)`

- Actualizar
    - `update_one(filtro, actualizaci√≥n)`
    - `update_many(filtro, actualizaci√≥n)`

- Eliminar
    - `delete_one(filtro)`
    - `delete_many(filtro)`

- Outros m√©todos √∫tiles
    - `count_documents(filtro)` ‚Üí conta documentos que cumpren un filtro.
    - `aggregate(pipeline)` ‚Üí permite usar pipelines de agregaci√≥n.
    - `distinct(campo)` ‚Üí valores √∫nicos dun campo.

### 1.4. Cursor
Obxecto retornado por `find()` que permite iterar sobre os resultados.

**M√©todos destacados**:
- `limit(n)` ‚Üí limita o resultado a `n` documentos.
- `sort(campo,orde)` ‚Üí Ordena documentos segundo un `campo` no sentido indicado por `orde`.
- `skip(n)` ‚Üí permite saltarse os `n` primeiros documentos.


## 2. Conexi√≥n a MongoDB
Para establecer unha conexi√≥n a un cl√∫ster mongo creamos un novo obxecto `MongoClient` chamando ao constructor e pas√°ndolle como par√°metro a nosa *cadea de conexi√≥n*. 

Unha vez feito iso podemos acceder a calquera BD empregando o seguinte formato:
```python
bd = cliente["nome_bd"]
```

Podemos acceder a calquera **colecci√≥n** do seguinte xeito:
```python
coeleccion = bd["nome_coleccion"]
```
### 2.1. Conexi√≥n a un servidor local
Neste caso bastar√≠a con indicar a url.


```python
from pymongo import MongoClient

# Creamos obxecto cliente establecendo a conexi√≥n

cliente = MongoClient("mongodb://localhost:27017/")

# Recuperamos unha BD
bd = cliente["mibd"]

# Recuperamos unha colecci√≥n
coleccion = bd["gente"]

# Amosamos o primeiro elemento da colecci√≥n
print(coleccion.find_one())
```

### 2.2. Conexi√≥n a MongoDB Atlas
Para Realizar a conexi√≥n ao noso cl√∫ster Atlas podemos obter a cadea de conexi√≥n seleccionando a opci√≥n `connect` na interfaz web, igual que fixemos para *Compass* ou *Mongosh*.



```python
# Exemplo de conexi√≥n

# Asignar √° variable `cadea de conexi√≥n` a t√∫a cadea de conexi√≥n.
cadea_conexion = "<introduce aqu√≠ a t√∫a cadea de conexi√≥n>"

# Creamos o obxecto cliente
cliente = MongoClient(cadea_conexion)

#Recuperamos unha BD
bd = cliente["sample_mflix"]

# Recuperamos unha colecci√≥n
coleccion = bd["movies"]

# Amosamos a colecci√≥n
for x in coleccion.find():
    print(x)
```

Hay que substituir a cadena pola nosa. Para obtela podemos facelo a trav√©s da web de **Atlas**. `Connect` -> `driver` -> `python`.
## 3. Inserir documentos

### 3.1. Inserir un √∫nico documento
Para inserir un documento primeiro creamos un *documento*, que ser√° un `dict` cos campos e valores a inserir. Para facelo empregaremos o m√©todo `insert_one()` da colecci√≥n. Antes diso deberemos obter a *colecci√≥n* a partir da *bd* e a *bd* a partir do cliente.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]
coleccion

# Creamos o documento a inserir
documento = {
    "nome": "Adri√°n Blanco",
    "idade": 41,
    "profesion": "profesor"
}

# Chamamos √° funci√≥n `insertOne()` para realizar a inserci√≥n.
resultado = coleccion.insert_one(documento)

# Comprobamos se a operaci√≥n se realizou con √©xito
print(resultado.inserted_id)
```

### 3.2. Inserir varios documentos
O proceso para inserir varios documentos √© moi semellante ao que vimos para un s√≥ documento. En vez de inserir un `dict` inserimos unha `lista` de `dict`.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]
coleccion

# Creamos a lista de documentos a inserir
docs = [
    {"nome": "Ana", "idade": 20},
    {"nome": "Xos√©", "idade": 25}
]

# Chamamos √° funci√≥n `insertOne()` para realizar a inserci√≥n.
resultado = coleccion.insert_many(docs)

# Comprobamos se a operaci√≥n se realizou con √©xito
print(resultado.inserted_ids)
```

## 4. Consultar documentos
As consultas realizanse de forma moi parecida √° empregada no shell de mongo, cos m√©todos `find()` e `find_one()`.

### 4.1. Obter un documento
O m√©todo `find_one()` devolve un obxecto `dict`.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Obtemos o documento
doc = coleccion.find_one()

# Amos√°molo
print(doc)
```

### 4.2. Obter varios documentos
De forma an√°loga, o m√©todo `find()` debolve un obxecto `cursor` que permite iterar polos distintos documentos recuperados.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Obtemos os documentos
docs = coleccion.find()

# Recorremos e amosamos os documentos
for doc in docs:
    print(doc)
```

### 4.3. Consulta con filtro
Os par√°metros pasados a ambos m√©todos (`find()` e `find_one()`) constr√∫ense exactamente igual que ao empregar o shell de mongo. Isto permite:
- Empregar filtros nas consultas


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Obtemos os documentos filtrados 
docs = coleccion.find({"idade": {"$gt": 30}})

for doc in docs:
    print(doc)
```

### 4.4. Consulta con proxecci√≥n
- Realizar proxecci√≥ns para s√≥ amosar determinados campos:


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Obtemos os documentos 
docs = coleccion.find({}, {"_id": 0, "nome": 1}) 
for doc in docs:
    print(doc)

```

## 5. Actualizaci√≥n de documentos
As actualizaci√≥ns real√≠zanse de forma moi semellante √°s inserci√≥ns.
### 5.1. Actualizar un documento
Para actualizar un documento empregamos o m√©todo `update_one()`


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Actualizamos o documento. Seleccionamos empregando un filtro e modificamos co operador `$set`
resultado = coleccion.update_one(
    {"nome": "Ana"},
    {"$set": {"idade": 22}}
)

# Amosamos o n√∫mero de documentos modificados
print(f"Documentos modificados: {resultado.modified_count}")
```

Para actualizar varios documentos empr√©gase o m√©todo `update()`:


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Actualizamos os documentos
resultado = coleccion.update_many(
    {"idade": {"$lt": 30}},
    {"$inc": {"idade": 1}}
)

# Amosamos o n√∫mero de documentos modificados
print(f"Documentos modificados: {resultado.modified_count}")

```

## 6. Eliminar documentos
Para elminar documentos empr√©ganse os m√©todos `update_one()` e `update_many()`.

### 6.1. Eliminar un documento
Empr√©gase o m√©todo `update_one()`. Como par√°metro p√°saselle un *json* cos filtros a aplicar para seleccionar o documento a eliminar. Borrarse a primeira coincidencia.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Eliminamos o documento
resultado = coleccion.delete_one({"nome": "Xos√©"})

# comprobamos o resultado
print(f"Documentos eliminados: {resultado.deleted_count}")
```

### 6.2. Eliminar varios documentos
Para elminar varios documentos cunha soa instruci√≥n empr√©gase a funci√≥n `update_many()`. Acepta os mesmos par√°metros e difer√©nciase en que elimina todas as coincidencias, non s√≥ a primeira.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Eliminamos os documentos
resultado = coleccion.delete_many({"idade": {"$gt": 50}})

# comprobamos o resultado
print(f"Documentos eliminados: {resultado.deleted_count}")

```

## 7. Uso de Aggregation Pipeline en Python

O m√©todo √© exactamente igual ao shell, pero pasando unha lista de dicionarios:


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["sample_mflix"]
coleccion = bd["movies"]

# Especificamos o pipeline de agregaci√≥n
pipeline = [
    {"$match": {"genres": "Drama"}},
    {"$group": {"_id": "$year", "total": {"$sum": 1}}},
    {"$sort": {"total": -1}}
]

# Executamos a o m√©todo `aggregate` para realizar a consulta agregada
docs = bd["movies"].aggregate(pipeline)

# Percorremos o cursor amosando os resultados
for doc in docs:
    print(doc)
```

Para m√°is informaci√≥n sobre como construir *pipelines* de agregaci√≥n p√≥dese consultar a [secci√≥n correspondente](6.agregaci√≥ns.md) 

## 8. Crear √≠ndices
### Que √© un √≠ndice?
Un **√≠ndice** √© unha estrutura de datos adicional que permite **localizar documentos moito m√°is r√°pido** sen ter que percorrer toda a colecci√≥n. 

Bot√©moslle un ollo a como a fectan os √≠ndices ao comportamento de **MongoDB**:
- Sen √≠ndice ‚Üí MongoDB fai un **collection scan** (le todos os documentos).
- Con √≠ndice ‚Üí MongoDB consulta o √≠ndice a vai **directamente aos documentos relevantes**.

### Cando ten sentido crear un √≠ndice?
√â recomendable crear un √≠ndice sobre campos que:
- se usan frecuentemente en `find()`, `delete()`, `update()`.
- aparecen en filtros (`where`)
- se usan para ordenar (`sort`)
- se usan en combinaci√≥n (√≠ndices compostos)

### Creaci√≥n b√°sica de √≠ndices
Para crear un √≠ndice con *pymongo* empr√©gase o m√©todo `create_index()`. Acepta os seguintes par√°metros:
- Unha `string` co nome do campo (crear√≠ase un √≠ndice ascendente).
- Un array que cont√©n:
  - Unha `string` co nome do campo.
  - Un `int` para indicar se √© ascendente(`1`) ou descendente (`-1`).
- Un array de tuplas (`campo`, `orde`) permitir√≠anos crear un **√≠ndice composto**. √â √∫til se se realizan frecuentemente consultas sobre eses dous campos. A orde dos compos no √≠ndice composto √© importante.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Creaci√≥n dun √≠ndice ascendente no campo `nome`
coleccion.create_index("nome")

# Creaci√≥n dun √≠ndice descendente no campo `idade`
coleccion.create_index([("idade", -1)])

# Creaci√≥n dun √≠ndice composto
# coleccion.create_index([("cidade", 1), ("idade", 1)])


```

### Uso de √≠ndices
Unha vez creados os √≠ndices, para usalos basta simplemente con realizar consultas normais sobre os mesmos. Por exemplo, ao ter creado un √≠ndice sobre o campo `idade` a seguinte consultaser√≠a moito m√°is r√°pida, ao non ter que revisar todos os documentos da colecci√≥n:


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Facemos a consulta
resultado = coleccion.find({"idade": 23})

# Amosamos os resultados
for doc in resultado:
    print(doc)
```

En consultas con ordenaci√≥n o √≠ndice e a√≠nda m√°is importante. 
- Se non hai √≠ndice MongoDB ten que ordenar toda a colecci√≥n en memoria. 
- Se o hai xa ter√≠a os datos ordenados diretamente.



```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Realizamos a consulta
resultado = coleccion.find().sort("idade", -1)

# Amosamos os resultados
for doc in resultado:
    print(doc)
```

### Outras operaci√≥ns con √≠ndices
O m√©todo `index_information` permite ver os √≠ndices dunha colecci√≥n.


```python
# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

print(coleccion.index_information())
```

## 9. Tratamento de datos extra√≠dos de MongoDB
Unha vez obtidos os datos desde MongoDB usando *PyMongo*, √© importante decidir **como traballalos en Python*. MongoDB √© unha base de datos orientada a documentos, polo que o tratamento posterior adoita facerse con estruturas din√°micas (dict, listas) ou ferramentas de an√°lise como pandas.

### Creaci√≥n de clases para almacenar documentos
√â posible modelar os documentos de MongoDB mediante clases de Python (por exemplo con `dataclasses` ou librar√≠as como **Pydantic**), o que achega:

- tipado m√°is claro  
- validaci√≥n de datos  
- mellor mantemento en proxectos grandes  

Sen embargo, no noso contexto **non nos interesa empregar clases**, polos seguintes motivos:

- MongoDB non imp√≥n un esquema fixo, polo que modelar clases pode introducir rigidez innecesaria.
- Nos exemplos e pr√°cticas c√©ntramonos en:
  - consultas
  - an√°lise exploratoria
  - agregaci√≥ns
  - exportaci√≥n de datos

O uso de `dict` √©:
- m√°is flexible
- m√°is pr√≥ximo ao modelo real de MongoDB
- m√°is axeitado para traballos de an√°lise e Big Data

> Polo tanto, traballaremos directamente cos documentos como **dicionarios de Python**, que √© o enfoque m√°is habitual en scripts, ETL e an√°lise de datos.

### Visualizaci√≥nde datos
Ao imprimir directamente un documento de MongoDB poden aparecer tipos especiais como `ObjectId`, `datetime` ou estruturas ani√±adas, o que fai que a sa√≠da non sexa moi lexible.

**Visualizaci√≥n con `pprint`**

O m√≥dulo est√°ndar pprint permite amosar os documentos de forma m√°is clara:


```python
from pprint import pprint

# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Realizamos a consulta
doc = coleccion.find_one()

# Amosamos o documento
pprint(doc)
```

**Visualizaci√≥n en formato JSON (`dumps`)**
Para unha visualizaci√≥n m√°is pr√≥xima a JSON (e compatible cos tipos BSON), p√≥dese utilizar:


```python
from bson.json_util import dumps

# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Realizamos a consulta
doc = coleccion.find_one()

# Amosamos o documento
print(dumps(doc, indent=2, ensure_ascii=False))

```

### 9.3. Conversi√≥n de colecci√≥ns ou consultas a pandas

Pandas √© unha ferramenta excelente para **an√°lise de datos**, estat√≠sticas e visualizaci√≥n, pero **non √© a mellor opci√≥n para transformaci√≥ns complexas nin grandes volumes**.

O fluxo habitual √©:

1. Executar unha consulta ou agregaci√≥n en MongoDB  
2. Converter o resultado a unha lista de dicionarios  
3. Crear un `DataFrame` de pandas  

#### Proceso b√°sico


```python
import pandas as pd

# Obtemos a BD e a colecci√≥n
bd = cliente["proba_pymongo"]
coleccion = bd["xente"]

# Almacenamos a consulta nun `cursor`
cursor = coleccion.find()

# Pasamos o `cursor` ao tipo `list`
docs = list(cursor)

# Creamos o dataframe a partir dunha lista de dicts.
df = pd.DataFrame(docs)

# Se o comapo _id non se vai usar como identificador ¬¥habitual convertilo a texto
df["_id"] = df["_id"].astype(str)

df

```

#### Nota importante sobre o uso de pandas

‚úî **pandas √© axeitado para**:
- an√°lise exploratoria
- estat√≠sticas
- visualizaci√≥n

‚úò **non √© axeitado para**:
- grandes volumes de datos
- transformaci√≥ns complexas
- procesado distribu√≠do

üëâ As **transformaci√≥ns deben facerse previamente**:
- en MongoDB usando `aggregate()`
- ou con Apache Spark (que se ver√° na secci√≥n correspondente)

---

### Exemplo: agregaci√≥n da colecci√≥n `zips` (sample_training)

Na base de datos `sample_training`, a colecci√≥n `zips` cont√©n informaci√≥n xeogr√°fica e demogr√°fica por c√≥digo postal.

#### Obxectivo do exemplo

Obter:
- poboaci√≥n total por estado (`state`)
- n√∫mero de c√≥digos postais por estado



```python
# Obtemos a BD e a colecci√≥n
bd = cliente["sample_training"]
coleccion = bd["zips"]

# Construimos o pipeline
pipeline = [
    {
        "$group": {
            "_id": "$state",
            "poboacion_total": {"$sum": "$pop"},
            "num_zips": {"$sum": 1}
        }
    },
    {
        "$sort": {"poboacion_total": -1}
    }
]

# Realizamos a consulta agregada
cursor = coleccion.aggregate(pipeline)

```

As√≠:
- A agregaci√≥n faise no servidor de MongoDB
- Pandas s√≥ recivve o resultado final agregado
O seguinte paso √© convertir o resultado a pandas


```python
import pandas as pd

# Convertimos o cursor ao tipo list
docs = list(cursor)

# Creamos o dataframe
df = pd.DataFrame(docs)

# Renomeamos o campo _id a estado (o campo estado cambiouse a _id ao agrupar)
df.rename(columns={"_id": "estado"}, inplace=True)
df

```

Esta *DataFrame* poder√≠a ser usado, posteriormente, para:
- gr√°ficas
- estad√≠sticas
- exportaci√≥n a outros formatos
- an√°lise


```python
# Obtenci√≥n das estad√≠sticas
df.describe()
```


```python
import matplotlib.pyplot as plt

# ordenar para que a gr√°fica sexa m√°is clara
df_ordenado = df.sort_values("poboacion_total", ascending=False).head(10)

plt.figure(figsize=(10, 6))
plt.bar(df_ordenado["estado"], df_ordenado["poboacion_total"])
plt.xticks(rotation=90)

plt.title("Poboaci√≥n total dos 10 estados m√°is poboados")
plt.xlabel("Estado")
plt.ylabel("Poboaci√≥n total")

plt.tight_layout()
plt.show()

```

## 10. Pechar a conexi√≥n

A conexi√≥n p√©chase automaticamente cando o obxecto √© destru√≠do, pero tam√©n se pode facer manualmente:


```python

cliente.close()
```


